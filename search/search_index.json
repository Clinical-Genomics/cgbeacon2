{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is a Beacon? Beacons are web-based discovery services for genetic variants. They are useful to know if the dataset present at any institution connected to the beacon network contains a given allele (or genetic variant). Beacons are an efficient way to share valuable genetic information without overly expose genomic data, due to privacy or security issues. You can find more info on the Beacon Network at this page: https://beacon-network.org/#/about . Beacon API v.1.0 can be found at [this link].(https://github.com/ga4gh-beacon/specification/blob/develop/beacon.md) Purpose This documentation illustrates how to set up a beacon based on python (>3.6) backend, a Flask server and a Mongodb instance. Our idea This project is under continuous improvement and our ultimate goal would be to update from the currently supported API 1.0 to the new API 2.0. The tool is intended to be ultimately integrated with the Scout VCF visualization tool but it's meant to work as well as a standalone. So having Scout installed is not a requirement. This software was developed by Clinical Genomics , Science For Life Laboratory, Stockholm.","title":"Home"},{"location":"#what-is-a-beacon","text":"Beacons are web-based discovery services for genetic variants. They are useful to know if the dataset present at any institution connected to the beacon network contains a given allele (or genetic variant). Beacons are an efficient way to share valuable genetic information without overly expose genomic data, due to privacy or security issues. You can find more info on the Beacon Network at this page: https://beacon-network.org/#/about . Beacon API v.1.0 can be found at [this link].(https://github.com/ga4gh-beacon/specification/blob/develop/beacon.md)","title":"What is a Beacon?"},{"location":"#purpose","text":"This documentation illustrates how to set up a beacon based on python (>3.6) backend, a Flask server and a Mongodb instance.","title":"Purpose"},{"location":"#our-idea","text":"This project is under continuous improvement and our ultimate goal would be to update from the currently supported API 1.0 to the new API 2.0. The tool is intended to be ultimately integrated with the Scout VCF visualization tool but it's meant to work as well as a standalone. So having Scout installed is not a requirement. This software was developed by Clinical Genomics , Science For Life Laboratory, Stockholm.","title":"Our idea"},{"location":"docker_run/","text":"Setting up a server from a Docker image The beacon app is consisting of a backend that is used for: - Creating and removing datasets - Adding or removing variants for one of more samples of a dataset - Loading demo data (not used in production, just in a test server) - Updating the genes in the database At the same time, the command beacon run starts a frontend server with the following API endpoints: Endpoint Methods Rule ----------------- --------- ------------------------------ api_v1.add POST /apiv1.0/add api_v1.delete POST /apiv1.0/delete api_v1.info GET /apiv1.0/ api_v1.query GET, POST /apiv1.0/query api_v1.query_form GET, POST /apiv1.0/query_form A Docker image for creating both backend and frontend containers is available on Docker Hub . Alternatively the Dockerfile used for creating the image is available in this repositiory. A local image of the repository can be created by moving the Dockerfile in the root folder of the app and from the same location, in a terminal, running the following command: docker build -t cgbeacon2 . The container with the docker image contains only the beacon app and its required libraries. In order to work the container must be connected with at least one other container hosting a running mongodb instance. Setting up the app backend: A simple running instance of the app backend connected to the database and ready to execute commands could be created in different ways. This is an example using docker-compose: Create a file docker-compose.yml containing the following code: version: '3' # usage: # sudo docker-compose build # sudo docker-compose up services: mongodb: image: mvertes/alpine-mongo container_name: mongodb ports: - '27017:27017' expose: - '27017' beacon-cli: environment: MONGODB_HOST: mongodb image: clinicalgenomics/cgbeacon2 container_name: beacon-cli links: - mongodb stdin_open: true # docker run -i tty: true # docker run -t Run the containers and open an interactive shell for the backend by typing: docker-compose run beacon-cli /bin/bash To populate the database with demo data (dataset + case variants) type: beacon add demo Exit from the execution of the images by typing exit Starting an app server connected to the database An app server instance connected to the server might be started in a similar way using Docker Compose. This is an example of a such server, listening for incoming requests on port 6000, from hosts outside the container. Example of docker-compose.yml file: version: '3' services: mongodb: image: mvertes/alpine-mongo container_name: mongodb ports: - '27017:27017' expose: - '27017' beacon-web: environment: MONGODB_HOST: mongodb image: clinicalgenomics/cgbeacon2 container_name: beacon-web links: - mongodb expose: - '6000' ports: - '6000:6000' command: bash -c 'beacon run --host 0.0.0.0' Run the server as a service (detached mode) by typing docker.compose up -d The server should be now listing for requests. Test that it is working by sending a request to the beacon info endpoint from another terminal window: curl -X GET 'http://127.0.0.1:6000/apiv1.0/' Stop the server by typing: docker.compose down","title":"Running the demo with Docker"},{"location":"docker_run/#setting-up-a-server-from-a-docker-image","text":"The beacon app is consisting of a backend that is used for: - Creating and removing datasets - Adding or removing variants for one of more samples of a dataset - Loading demo data (not used in production, just in a test server) - Updating the genes in the database At the same time, the command beacon run starts a frontend server with the following API endpoints: Endpoint Methods Rule ----------------- --------- ------------------------------ api_v1.add POST /apiv1.0/add api_v1.delete POST /apiv1.0/delete api_v1.info GET /apiv1.0/ api_v1.query GET, POST /apiv1.0/query api_v1.query_form GET, POST /apiv1.0/query_form A Docker image for creating both backend and frontend containers is available on Docker Hub . Alternatively the Dockerfile used for creating the image is available in this repositiory. A local image of the repository can be created by moving the Dockerfile in the root folder of the app and from the same location, in a terminal, running the following command: docker build -t cgbeacon2 . The container with the docker image contains only the beacon app and its required libraries. In order to work the container must be connected with at least one other container hosting a running mongodb instance.","title":"Setting up a server from a Docker image"},{"location":"docker_run/#setting-up-the-app-backend","text":"A simple running instance of the app backend connected to the database and ready to execute commands could be created in different ways. This is an example using docker-compose: Create a file docker-compose.yml containing the following code: version: '3' # usage: # sudo docker-compose build # sudo docker-compose up services: mongodb: image: mvertes/alpine-mongo container_name: mongodb ports: - '27017:27017' expose: - '27017' beacon-cli: environment: MONGODB_HOST: mongodb image: clinicalgenomics/cgbeacon2 container_name: beacon-cli links: - mongodb stdin_open: true # docker run -i tty: true # docker run -t Run the containers and open an interactive shell for the backend by typing: docker-compose run beacon-cli /bin/bash To populate the database with demo data (dataset + case variants) type: beacon add demo Exit from the execution of the images by typing exit","title":"Setting up the app backend:"},{"location":"docker_run/#starting-an-app-server-connected-to-the-database","text":"An app server instance connected to the server might be started in a similar way using Docker Compose. This is an example of a such server, listening for incoming requests on port 6000, from hosts outside the container. Example of docker-compose.yml file: version: '3' services: mongodb: image: mvertes/alpine-mongo container_name: mongodb ports: - '27017:27017' expose: - '27017' beacon-web: environment: MONGODB_HOST: mongodb image: clinicalgenomics/cgbeacon2 container_name: beacon-web links: - mongodb expose: - '6000' ports: - '6000:6000' command: bash -c 'beacon run --host 0.0.0.0' Run the server as a service (detached mode) by typing docker.compose up -d The server should be now listing for requests. Test that it is working by sending a request to the beacon info endpoint from another terminal window: curl -X GET 'http://127.0.0.1:6000/apiv1.0/' Stop the server by typing: docker.compose down","title":"Starting an app server connected to the database"},{"location":"env_install/","text":"Beacon setup Prerequisites Installation - on a virtual environment using pip Server settings Running the server Prerequisites A virtual environment containing Python 3.6+ Bedtools installed in the virtual environment. To install it using the bioconda channel type: conda install -n your_beacon_environment -c bioconda bedtools A working instance of MongoDB . From the mongo shell you can create a database using this syntax: use <name_of_database> Database name can be customized. If you don't have any preferences, cgbeacon2 will work just fine. Installation Once activated the virtual environment, clone this repository from github using this command: git clone https://github.com/Clinical-Genomics/cgbeacon2.git Change directory to the cloned folder and from there, install the software using the following command: pip install -e . To make sure the software is installed, from the terminal, you can run the following command: beacon --version Server settings Default server settings are specified in the config.py file under cgbeacon2/instance Secret key and database connection parameters depend on your server implementation, and for the purpose of testing the software they might be left unchanged. # secret key: SECRET_KEY = \"MySuperSecretKey\" # Database connection parameters DB_HOST = \"127.0.0.1\" DB_PORT = 27017 DB_NAME = \"cgbeacon2-test\" DB_URI = f\"mongodb://{DB_HOST}:{DB_PORT}/{DB_NAME}\" ORGANISATION and BEACON_OBJ dictionaries contain values that are returned by the server when users or other beacons send a request to the info endpoint(/), so they should be filled in properly in a production environment: ORGANISATION = dict( id=\"scilifelab\", # mandatory name=\"Clinical Genomics, SciLifeLab\", # mandatory description=\"A science lab\", address=\"\", contactUrl=\"\", info=[], logoUrl=\"\", welcomeUrl=\"\", ) BEACON_OBJ = dict( id=\"SciLifeLab-beacon\", # mandatory name=\"SciLifeLab Stockholm Beacon\", # mandatory organisation=ORGANISATION, # mandatory alternativeUrl=\"http//scilifelab.beacon_alt.se\", createDateTime=\"2015-06-15T00:00.000Z\", description=\"Beacon description\", info=[], welcomeUrl=\"http//scilifelab.beacon.se\", ) The info field of both object can contain a series of custom key/values that better describe your organisation and its beacon server. OAUTH2 permissions layer parameters are responsible for the authentication of incoming requests bearing a auth token, and should be left unchanged: ELIXIR_OAUTH2 = dict( server=\"https://login.elixir-czech.org/oidc/jwk\", # OAuth2 server that returns JWK public key issuers=[ \"https://login.elixir-czech.org/oidc/\" ], # Authenticated Bearer token issuers userinfo=\"https://login.elixir-czech.org/oidc/userinfo\", # Where to send access token to view user data (permissions, statuses, ...) audience=[], # List of strings. Service(s) the token is intended for. (key provided by the Beacon Network administrator) verify_aud=False, # if True, force verify audience for provided token bona_fide_requirements=\"https://doi.org/10.1038/s41431-018-0219-y\", ) Running the server To run the server, from the command line, you can use the following command: beacon run","title":"Deploying on a virtual environment"},{"location":"env_install/#beacon-setup","text":"Prerequisites Installation - on a virtual environment using pip Server settings Running the server","title":"Beacon setup"},{"location":"env_install/#prerequisites","text":"A virtual environment containing Python 3.6+ Bedtools installed in the virtual environment. To install it using the bioconda channel type: conda install -n your_beacon_environment -c bioconda bedtools A working instance of MongoDB . From the mongo shell you can create a database using this syntax: use <name_of_database> Database name can be customized. If you don't have any preferences, cgbeacon2 will work just fine.","title":"Prerequisites"},{"location":"env_install/#installation","text":"Once activated the virtual environment, clone this repository from github using this command: git clone https://github.com/Clinical-Genomics/cgbeacon2.git Change directory to the cloned folder and from there, install the software using the following command: pip install -e . To make sure the software is installed, from the terminal, you can run the following command: beacon --version","title":"Installation"},{"location":"env_install/#server-settings","text":"Default server settings are specified in the config.py file under cgbeacon2/instance Secret key and database connection parameters depend on your server implementation, and for the purpose of testing the software they might be left unchanged. # secret key: SECRET_KEY = \"MySuperSecretKey\" # Database connection parameters DB_HOST = \"127.0.0.1\" DB_PORT = 27017 DB_NAME = \"cgbeacon2-test\" DB_URI = f\"mongodb://{DB_HOST}:{DB_PORT}/{DB_NAME}\" ORGANISATION and BEACON_OBJ dictionaries contain values that are returned by the server when users or other beacons send a request to the info endpoint(/), so they should be filled in properly in a production environment: ORGANISATION = dict( id=\"scilifelab\", # mandatory name=\"Clinical Genomics, SciLifeLab\", # mandatory description=\"A science lab\", address=\"\", contactUrl=\"\", info=[], logoUrl=\"\", welcomeUrl=\"\", ) BEACON_OBJ = dict( id=\"SciLifeLab-beacon\", # mandatory name=\"SciLifeLab Stockholm Beacon\", # mandatory organisation=ORGANISATION, # mandatory alternativeUrl=\"http//scilifelab.beacon_alt.se\", createDateTime=\"2015-06-15T00:00.000Z\", description=\"Beacon description\", info=[], welcomeUrl=\"http//scilifelab.beacon.se\", ) The info field of both object can contain a series of custom key/values that better describe your organisation and its beacon server. OAUTH2 permissions layer parameters are responsible for the authentication of incoming requests bearing a auth token, and should be left unchanged: ELIXIR_OAUTH2 = dict( server=\"https://login.elixir-czech.org/oidc/jwk\", # OAuth2 server that returns JWK public key issuers=[ \"https://login.elixir-czech.org/oidc/\" ], # Authenticated Bearer token issuers userinfo=\"https://login.elixir-czech.org/oidc/userinfo\", # Where to send access token to view user data (permissions, statuses, ...) audience=[], # List of strings. Service(s) the token is intended for. (key provided by the Beacon Network administrator) verify_aud=False, # if True, force verify audience for provided token bona_fide_requirements=\"https://doi.org/10.1038/s41431-018-0219-y\", )","title":"Server settings"},{"location":"env_install/#running-the-server","text":"To run the server, from the command line, you can use the following command: beacon run","title":"Running the server"},{"location":"loading/","text":"Adding data to the database Dataset and variant data can be loaded into the database using specific the specific command line. To visualize command line options, from the terminal you can user the following command: beacon --help . The default procedure to add variants to the beacon is always the following: Create a dataset to link your variants to. Load variants from a VCF file for one or more samples, specifying which dataset these variants belong to. How to add: Demo data Gene data Creating an authorized user for using the APIs A new dataset (custom data) Variants (custom data) using the command line Variants (custom data) using the REST API Demo data Demo data consisting in a test dataset with public access and a set of variants (SNVs and structural variants of different type) is available under the cgbeacon2/resources/demo folder. You don't need to load this data manually since the following command will take care of everything: beacon add demo Adding/updating gene data In order to accept add variants requests containing the genes option, the database should be pre-populated with gene data. VCF files can in fact be filtered by genes only if gene information containing chromosome, start and stop coordinates are already available when the variants load command is executed. To load genes into database or to update the database gene collection, run the following command: beacon update genes Options: -build [GRCh37|GRCh38] Genome assembly (default:GRCh37) Creating an authorized user for using the APIs An API user is required whenever variants are by sending a request to the Beacon API. One or more API users can be created using the command: beacon add user Options: --uid TEXT User ID [required] --name TEXT User name [required] --token TEXT If not specified, the token will be created automatically --desc TEXT User description --url TEXT User url --help Show this message and exit. If no token is specified, a random user token will be created in the database for this user. Adding a new dataset A new dataset can be created with the following command: beacon add dataset --did <dataset_id> --name <\"A dataset name\"> --build <GRCh37|GRCh38> --authlevel <public|registered|controlled> The above parameters (ds-id, name, build, authlevel) are mandatory. If user doesn't specify any genome build then the default build used is GRCh37. One dataset can be associated to variants called using only one genome build. authlevel parameter will be used in queries to return results according to the request authentication level. Public datasets can be interrogated by any beacon and any user in general and should not be used to store sensitive data such as individual phenotypes. Bona fide researchers logged in via the Elixir AAI will be able to access data store in registered datasets . Controlled access datasets might be used to store sensitive information and will be accessed only by users that have a signed agreement and their access approved by a Data Access Committee (DAC). More info about the Elixir AAI authentication is available here Other optional parameters that can be provided to improve the dataset description are the following. --desc TEXT dataset description --version FLOAT dataset version, i.e. 1.0 --url TEXT external url --cc TEXT consent code key. i.e. HMB --update The --update flag will allow to modify the information for a dataset that is already existing in the database. Adding variant data using the command line Variant data can be loaded to the database using the following command: beacon add variants Options: --ds TEXT dataset ID [required] --vcf PATH [required] --sample TEXT one or more samples to save variants for [required] --panel PATH one or more bed files containing genomic intervals ds (dataset id) and vcf (path to the VCF file containing the variants) are mandatory parameters. One or more samples included in the VCF file must also be specified. To specify multiple samples use the -sample parameter multiple times (example -sample sampleA -sample sampleB ..). VCF files might as well be filtered by genomic intervals prior to variant uploading. To upload variants filtered by multiple panels use the options -panel panelA -panel panelB, providing the path to a bed file containing the genomic intervals of interest. Additional variants for the same sample(s) and the same dataset might be added any time by running the same beacon add variants specifying another VCF file. Whenever the variant is already found for the same sample and the same dataset it will not be saved twice. Adding variant data using the REST API Variant data can be alternatively loaded to the Beacon by sending a request to the /apiv1.0/add endpoint. This Endpoint is accepting json data from POST requests. If the request parameters are correct it will return a response with code 200 (success) and message \"Saving variants to Beacon\", whole it will start the actual thread that will save variants to database. Sending an add request to the API Apart from the header, an add request should contain the following parameters: - dataset_id (mandatory): string dentifier for a dataset - vcf_path (mandatory): path to variants VCF file - assemblyId (mandatory) : Genome build used in variant calling (\"GRCh37\", \"GRCh38\") - samples (mandatory): list of samples to extract variants from in VCF file - genes (optional): an object containing two keys: - ids : list of genes ids to be used to filter VCF file (only variants included in these genes will be saved to database). - id_type *: either \"HGNC\" or \"Ensembl\", to specify which type of ID format ids refers to. All genes in the list must be of the same type (for example all Ensembl IDs). HTML Requests to add variants should contain an auth_token header which corresponds to the token of a pre-existing API user . API users are created exclusively using the command line. Follow these instructions to create a new API user. Once the user is created in the database, make sure the request to the add API contains the following header parameters: - Content-Type : application/json - X-Auth-Token : auth_token Example of a valid POST request to the add endpoint: curl -X POST \\ -H 'Content-Type: application/json' \\ -H 'X-Auth-Token: auth_token' \\ -d '{\"dataset_id\": \"test_public\", \"vcf_path\": \"path/to/cgbeacon2/cgbeacon2/resources/demo/test_trio.vcf.gz\", \"samples\" : [\"ADM1059A1\", \"ADM1059A2\"], \"genes\" : {\"ids\": [17284, 29669, 11592], \"id_type\":\"HGNC\"}, \"assemblyId\": \"GRCh37\"}' http://localhost:5000/apiv1.0/add In order for the genes option to work, it is necessary to load genes data into the database via the command line *. Instructions on how to load genes info into the database are available here","title":"Loading datasets and variants"},{"location":"loading/#adding-data-to-the-database","text":"Dataset and variant data can be loaded into the database using specific the specific command line. To visualize command line options, from the terminal you can user the following command: beacon --help . The default procedure to add variants to the beacon is always the following: Create a dataset to link your variants to. Load variants from a VCF file for one or more samples, specifying which dataset these variants belong to.","title":"Adding data to the database"},{"location":"loading/#how-to-add","text":"Demo data Gene data Creating an authorized user for using the APIs A new dataset (custom data) Variants (custom data) using the command line Variants (custom data) using the REST API","title":"How to add:"},{"location":"loading/#demo-data","text":"Demo data consisting in a test dataset with public access and a set of variants (SNVs and structural variants of different type) is available under the cgbeacon2/resources/demo folder. You don't need to load this data manually since the following command will take care of everything: beacon add demo","title":"Demo data"},{"location":"loading/#addingupdating-gene-data","text":"In order to accept add variants requests containing the genes option, the database should be pre-populated with gene data. VCF files can in fact be filtered by genes only if gene information containing chromosome, start and stop coordinates are already available when the variants load command is executed. To load genes into database or to update the database gene collection, run the following command: beacon update genes Options: -build [GRCh37|GRCh38] Genome assembly (default:GRCh37)","title":"Adding/updating gene data"},{"location":"loading/#creating-an-authorized-user-for-using-the-apis","text":"An API user is required whenever variants are by sending a request to the Beacon API. One or more API users can be created using the command: beacon add user Options: --uid TEXT User ID [required] --name TEXT User name [required] --token TEXT If not specified, the token will be created automatically --desc TEXT User description --url TEXT User url --help Show this message and exit. If no token is specified, a random user token will be created in the database for this user.","title":"Creating an authorized user for using the APIs"},{"location":"loading/#adding-a-new-dataset","text":"A new dataset can be created with the following command: beacon add dataset --did <dataset_id> --name <\"A dataset name\"> --build <GRCh37|GRCh38> --authlevel <public|registered|controlled> The above parameters (ds-id, name, build, authlevel) are mandatory. If user doesn't specify any genome build then the default build used is GRCh37. One dataset can be associated to variants called using only one genome build. authlevel parameter will be used in queries to return results according to the request authentication level. Public datasets can be interrogated by any beacon and any user in general and should not be used to store sensitive data such as individual phenotypes. Bona fide researchers logged in via the Elixir AAI will be able to access data store in registered datasets . Controlled access datasets might be used to store sensitive information and will be accessed only by users that have a signed agreement and their access approved by a Data Access Committee (DAC). More info about the Elixir AAI authentication is available here Other optional parameters that can be provided to improve the dataset description are the following. --desc TEXT dataset description --version FLOAT dataset version, i.e. 1.0 --url TEXT external url --cc TEXT consent code key. i.e. HMB --update The --update flag will allow to modify the information for a dataset that is already existing in the database.","title":"Adding a new dataset"},{"location":"loading/#adding-variant-data-using-the-command-line","text":"Variant data can be loaded to the database using the following command: beacon add variants Options: --ds TEXT dataset ID [required] --vcf PATH [required] --sample TEXT one or more samples to save variants for [required] --panel PATH one or more bed files containing genomic intervals ds (dataset id) and vcf (path to the VCF file containing the variants) are mandatory parameters. One or more samples included in the VCF file must also be specified. To specify multiple samples use the -sample parameter multiple times (example -sample sampleA -sample sampleB ..). VCF files might as well be filtered by genomic intervals prior to variant uploading. To upload variants filtered by multiple panels use the options -panel panelA -panel panelB, providing the path to a bed file containing the genomic intervals of interest. Additional variants for the same sample(s) and the same dataset might be added any time by running the same beacon add variants specifying another VCF file. Whenever the variant is already found for the same sample and the same dataset it will not be saved twice.","title":"Adding variant data using the command line"},{"location":"loading/#adding-variant-data-using-the-rest-api","text":"Variant data can be alternatively loaded to the Beacon by sending a request to the /apiv1.0/add endpoint. This Endpoint is accepting json data from POST requests. If the request parameters are correct it will return a response with code 200 (success) and message \"Saving variants to Beacon\", whole it will start the actual thread that will save variants to database.","title":"Adding variant data using the REST API"},{"location":"loading/#sending-an-add-request-to-the-api","text":"Apart from the header, an add request should contain the following parameters: - dataset_id (mandatory): string dentifier for a dataset - vcf_path (mandatory): path to variants VCF file - assemblyId (mandatory) : Genome build used in variant calling (\"GRCh37\", \"GRCh38\") - samples (mandatory): list of samples to extract variants from in VCF file - genes (optional): an object containing two keys: - ids : list of genes ids to be used to filter VCF file (only variants included in these genes will be saved to database). - id_type *: either \"HGNC\" or \"Ensembl\", to specify which type of ID format ids refers to. All genes in the list must be of the same type (for example all Ensembl IDs). HTML Requests to add variants should contain an auth_token header which corresponds to the token of a pre-existing API user . API users are created exclusively using the command line. Follow these instructions to create a new API user. Once the user is created in the database, make sure the request to the add API contains the following header parameters: - Content-Type : application/json - X-Auth-Token : auth_token Example of a valid POST request to the add endpoint: curl -X POST \\ -H 'Content-Type: application/json' \\ -H 'X-Auth-Token: auth_token' \\ -d '{\"dataset_id\": \"test_public\", \"vcf_path\": \"path/to/cgbeacon2/cgbeacon2/resources/demo/test_trio.vcf.gz\", \"samples\" : [\"ADM1059A1\", \"ADM1059A2\"], \"genes\" : {\"ids\": [17284, 29669, 11592], \"id_type\":\"HGNC\"}, \"assemblyId\": \"GRCh37\"}' http://localhost:5000/apiv1.0/add In order for the genes option to work, it is necessary to load genes data into the database via the command line *. Instructions on how to load genes info into the database are available here","title":"Sending an add request to the API"},{"location":"queries/","text":"Beacon endpoints and queries Info endpoint Query endpoint Queries using the web interface Advanced query parameters Server endpoints - /info . General info regarding this Beacon, including a description of its datasets, API version, sample count etc, can be obtained by sending a GET request using the following shell command: curl -X GET 'http://localhost:5000/apiv1.0/info' Demo beacon will reply to this request with a JSON object like this: {\"alternativeUrl\":null,\"apiVersion\":\"v1.0.0\",\"createDateTime\":\"Tue, 23 Jun 2020 14:33:52 GMT\",\"datasets\":[{\"assembly_id\":\"GRCh37\",\"callCount\":483,\"created\":\"Tue, 23 Jun 2020 14:33:52 GMT\",\"id\":\"test_public\",\"info\":{\"accessType\":\"PUBLIC\"},\"name\":\"Test public dataset\",\"sampleCount\":1,\"updated\":\"Tue, 23 Jun 2020 14:33:53 GMT\",\"variantCount\":408,\"version\":1.0}],\"description\":\"Beacon description\",\"id\":\"SciLifeLab-beacon\",\"name\":\"SciLifeLab Stockholm Beacon\",\"organisation\":{\"address\":\"\",\"contactUrl\":\"\",\"description\":\"A science lab\",\"id\":\"scilifelab\",\"info\":[],\"logoUrl\":\"\",\"name\":\"Clinical Genomics, SciLifeLab\",\"welcomeUrl\":\"\"},\"sampleAlleleRequests\":[{\"alternateBases\":\"A\",\"assemblyId\":\"GRCh37\",\"datasetIds\":[\"test_public\"],\"includeDatasetResponses\":\"HIT\",\"referenceBases\":\"C\",\"referenceName\":\"1\",\"start\":156146085},{\"assemblyId\":\"GRCh37\",\"includeDatasetResponses\":\"ALL\",\"referenceBases\":\"C\",\"referenceName\":\"20\",\"start\":54963148,\"variantType\":\"DUP\"}],\"updateDateTime\":\"Tue, 23 Jun 2020 14:33:53 GMT\",\"version\":\"v1.1\",\"welcomeUrl\":null} - /query . Query endpoint supports both GET and POST requests. Example of a GET request: curl -X GET \\ 'http://localhost:5000/apiv1.0/query?referenceName=1&referenceBases=C&start=156146085&assemblyId=GRCh37&alternateBases=A' Example of a POST request: curl -X POST \\ -H 'Content-Type: application/json' \\ -d '{\"referenceName\": \"1\", \"start\": 156146085, \"referenceBases\": \"C\", \"alternateBases\": \"A\", \"assemblyId\": \"GRCh37\", \"includeDatasetResponses\": \"HIT\"}' http://localhost:5000/apiv1.0/query The Beacon reply to a query of this type would be a json object where the \"exist\" key will be true if the allele is found, otherwise it will be false. {\"allelRequest\":{\"alternateBases\":\"A\",\"assemblyId\":\"GRCh37\",\"datasetIds\":[],\"includeDatasetResponses\":\"NONE\",\"referenceBases\":\"C\",\"referenceName\":\"1\",\"start\":\"156146085\"},\"apiVersion\":\"1.0.0\",\"beaconId\":\"SciLifeLab-beacon\",\"datasetAlleleResponses\":[],\"error\":null,\"exists\":true} Web interface A simple web interface to perform interactive queries can be used by typing the following address in any browser window: http://127.0.0.1:5000/apiv1.0/query_form At the moment this interface is disconnected with Elixir AAI so all queries will be limited to the available public datasets in the Beacon. Advanced queries Required parameters assemblyId : Genome build (GRC notation, example: GRCh37). referenceName : Chromosome name () 1-22, X, Y, MT). referenceBases : Reference bases for a variant. Accepted values: [ACGT]* . start : Precise start coordinate position, allele locus (0-based). start coordinate: for single positions, in general for retrieving information on SNVs and InDels. the use of start without an end parameter requires the use of referenceBases . start and end coordinates: In general used to retrieve information for structural variants where start and end exact positions are known. startMin : Minimum start coordinate for querying imprecise positions, for instance when a structural variants is suspected to have a breakpoint within a startMin and startMax interval. Similarly variants with the other breakpoint ending in another interval can be found by specifying endMin and endMax coordinates. startMax : Maximum start coordinate. See startMin . end : Precise end coordinate (0-based, exclusive). See start . endMin : Minimum end coordinate. See startMin . endMax : Maximum end coordinate. See startMin . Either Start and/or End coordinates or range coordinates must be specified in the query. Additional optional parameters variantType : is used especially to query structural variants. Examples: SNV, DEL, DUP, BND .. alternateBases : The bases that appear instead of the reference bases. Accepted values: [ACGT]* Either alternateBases or variantType is required in all queries datasetIds : specific dataset IDs to search in. If this parameter is not provided then all datasets of a beacon will be searched. includeDatasetResponses : whether if the beacon should return a dataset-specific response or a simple yes/no reply. Accepted values: ALL : return a specific result from all available datasets in the beacon. HIT : return a specific result from from all dataset where there is a positive match for the variant. MISS : return a specific result from from all dataset where the variant was not found. NONE : do not include dataset-specific info in the request. The same type of request is obtained when includeDatasetResponses parameter is not provided. The advantage of including includeDatasetResponses in query is that in case of positive match, other useful statistics will be returned at the dataset level, such as variantCount , callCount and sampleCount . This is an example of a positive match response from this beacon populated with demo data: {\"allelRequest\":{\"alternateBases\":\"A\",\"assemblyId\":\"GRCh37\",\"datasetIds\":[],\"includeDatasetResponses\":\"HIT\",\"referenceBases\":\"C\",\"referenceName\":\"1\",\"start\":156146085},\"apiVersion\":\"1.0.0\",\"beaconId\":\"SciLifeLab-beacon\",\"datasetAlleleResponses\":[{\"callCount\":1,\"datasetId\":\"test_public\",\"exists\":true,\"info\":{\"accessType\":\"PUBLIC\"},\"sampleCount\":1,\"variantCount\":1}],\"error\":null,\"exists\":true}","title":"Queries"},{"location":"queries/#beacon-endpoints-and-queries","text":"Info endpoint Query endpoint Queries using the web interface Advanced query parameters","title":"Beacon endpoints and queries"},{"location":"queries/#server-endpoints","text":"- /info . General info regarding this Beacon, including a description of its datasets, API version, sample count etc, can be obtained by sending a GET request using the following shell command: curl -X GET 'http://localhost:5000/apiv1.0/info' Demo beacon will reply to this request with a JSON object like this: {\"alternativeUrl\":null,\"apiVersion\":\"v1.0.0\",\"createDateTime\":\"Tue, 23 Jun 2020 14:33:52 GMT\",\"datasets\":[{\"assembly_id\":\"GRCh37\",\"callCount\":483,\"created\":\"Tue, 23 Jun 2020 14:33:52 GMT\",\"id\":\"test_public\",\"info\":{\"accessType\":\"PUBLIC\"},\"name\":\"Test public dataset\",\"sampleCount\":1,\"updated\":\"Tue, 23 Jun 2020 14:33:53 GMT\",\"variantCount\":408,\"version\":1.0}],\"description\":\"Beacon description\",\"id\":\"SciLifeLab-beacon\",\"name\":\"SciLifeLab Stockholm Beacon\",\"organisation\":{\"address\":\"\",\"contactUrl\":\"\",\"description\":\"A science lab\",\"id\":\"scilifelab\",\"info\":[],\"logoUrl\":\"\",\"name\":\"Clinical Genomics, SciLifeLab\",\"welcomeUrl\":\"\"},\"sampleAlleleRequests\":[{\"alternateBases\":\"A\",\"assemblyId\":\"GRCh37\",\"datasetIds\":[\"test_public\"],\"includeDatasetResponses\":\"HIT\",\"referenceBases\":\"C\",\"referenceName\":\"1\",\"start\":156146085},{\"assemblyId\":\"GRCh37\",\"includeDatasetResponses\":\"ALL\",\"referenceBases\":\"C\",\"referenceName\":\"20\",\"start\":54963148,\"variantType\":\"DUP\"}],\"updateDateTime\":\"Tue, 23 Jun 2020 14:33:53 GMT\",\"version\":\"v1.1\",\"welcomeUrl\":null} - /query . Query endpoint supports both GET and POST requests. Example of a GET request: curl -X GET \\ 'http://localhost:5000/apiv1.0/query?referenceName=1&referenceBases=C&start=156146085&assemblyId=GRCh37&alternateBases=A' Example of a POST request: curl -X POST \\ -H 'Content-Type: application/json' \\ -d '{\"referenceName\": \"1\", \"start\": 156146085, \"referenceBases\": \"C\", \"alternateBases\": \"A\", \"assemblyId\": \"GRCh37\", \"includeDatasetResponses\": \"HIT\"}' http://localhost:5000/apiv1.0/query The Beacon reply to a query of this type would be a json object where the \"exist\" key will be true if the allele is found, otherwise it will be false. {\"allelRequest\":{\"alternateBases\":\"A\",\"assemblyId\":\"GRCh37\",\"datasetIds\":[],\"includeDatasetResponses\":\"NONE\",\"referenceBases\":\"C\",\"referenceName\":\"1\",\"start\":\"156146085\"},\"apiVersion\":\"1.0.0\",\"beaconId\":\"SciLifeLab-beacon\",\"datasetAlleleResponses\":[],\"error\":null,\"exists\":true}","title":"Server endpoints"},{"location":"queries/#web-interface","text":"A simple web interface to perform interactive queries can be used by typing the following address in any browser window: http://127.0.0.1:5000/apiv1.0/query_form At the moment this interface is disconnected with Elixir AAI so all queries will be limited to the available public datasets in the Beacon.","title":"Web interface"},{"location":"queries/#advanced-queries","text":"","title":"Advanced queries"},{"location":"queries/#required-parameters","text":"assemblyId : Genome build (GRC notation, example: GRCh37). referenceName : Chromosome name () 1-22, X, Y, MT). referenceBases : Reference bases for a variant. Accepted values: [ACGT]* . start : Precise start coordinate position, allele locus (0-based). start coordinate: for single positions, in general for retrieving information on SNVs and InDels. the use of start without an end parameter requires the use of referenceBases . start and end coordinates: In general used to retrieve information for structural variants where start and end exact positions are known. startMin : Minimum start coordinate for querying imprecise positions, for instance when a structural variants is suspected to have a breakpoint within a startMin and startMax interval. Similarly variants with the other breakpoint ending in another interval can be found by specifying endMin and endMax coordinates. startMax : Maximum start coordinate. See startMin . end : Precise end coordinate (0-based, exclusive). See start . endMin : Minimum end coordinate. See startMin . endMax : Maximum end coordinate. See startMin . Either Start and/or End coordinates or range coordinates must be specified in the query.","title":"Required parameters"},{"location":"queries/#additional-optional-parameters","text":"variantType : is used especially to query structural variants. Examples: SNV, DEL, DUP, BND .. alternateBases : The bases that appear instead of the reference bases. Accepted values: [ACGT]* Either alternateBases or variantType is required in all queries datasetIds : specific dataset IDs to search in. If this parameter is not provided then all datasets of a beacon will be searched. includeDatasetResponses : whether if the beacon should return a dataset-specific response or a simple yes/no reply. Accepted values: ALL : return a specific result from all available datasets in the beacon. HIT : return a specific result from from all dataset where there is a positive match for the variant. MISS : return a specific result from from all dataset where the variant was not found. NONE : do not include dataset-specific info in the request. The same type of request is obtained when includeDatasetResponses parameter is not provided. The advantage of including includeDatasetResponses in query is that in case of positive match, other useful statistics will be returned at the dataset level, such as variantCount , callCount and sampleCount . This is an example of a positive match response from this beacon populated with demo data: {\"allelRequest\":{\"alternateBases\":\"A\",\"assemblyId\":\"GRCh37\",\"datasetIds\":[],\"includeDatasetResponses\":\"HIT\",\"referenceBases\":\"C\",\"referenceName\":\"1\",\"start\":156146085},\"apiVersion\":\"1.0.0\",\"beaconId\":\"SciLifeLab-beacon\",\"datasetAlleleResponses\":[{\"callCount\":1,\"datasetId\":\"test_public\",\"exists\":true,\"info\":{\"accessType\":\"PUBLIC\"},\"sampleCount\":1,\"variantCount\":1}],\"error\":null,\"exists\":true}","title":"Additional optional parameters"},{"location":"removing/","text":"Removing variants for one or more samples using the command line To remove all variants from one or more samples of a dataset you can use the following command: beacon delete variants --ds TEXT dataset ID [required] --sample TEXT one or more samples to remove variants for [required] Note that dataset ID (-ds) and sample are mandatory parameters. To specify multiple samples you should use the -sample option multiple times. Removing variants for one or more samples by using the API Authorized users can also remove variants by sending a request to the /apiv1.0/delete endpoint. This endpoint accepts json data DELETE requests. If the request parameters are correct it will return a response with code 200 (success) and message \"Deleting variants from Beacon\", whole it will start the actual thread that will remove variants from the database. The request to the add API should contain the following header parameters: - Content-Type : application/json - X-Auth-Token : auth_token Auth-token is the token created in the moment an API user is created in the database (documentation here ). Example of a DELETE request to delete variants: curl -X DELETE \\ -H 'Content-Type: application/json' \\ -H 'X-Auth-Token: auth_token' \\ -d '{\"dataset_id\": \"test_public\", \"samples\" : [\"ADM1059A1\", \"ADM1059A2\"]}' http://localhost:5000/apiv1.0/delete Removing a specific dataset Use the command to remove a dataset from the database: beacon delete dataset --id <dataset_id>","title":"Removing datasets and variants"},{"location":"removing/#removing-variants-for-one-or-more-samples-using-the-command-line","text":"To remove all variants from one or more samples of a dataset you can use the following command: beacon delete variants --ds TEXT dataset ID [required] --sample TEXT one or more samples to remove variants for [required] Note that dataset ID (-ds) and sample are mandatory parameters. To specify multiple samples you should use the -sample option multiple times.","title":"Removing variants for one or more samples using the command line"},{"location":"removing/#removing-variants-for-one-or-more-samples-by-using-the-api","text":"Authorized users can also remove variants by sending a request to the /apiv1.0/delete endpoint. This endpoint accepts json data DELETE requests. If the request parameters are correct it will return a response with code 200 (success) and message \"Deleting variants from Beacon\", whole it will start the actual thread that will remove variants from the database. The request to the add API should contain the following header parameters: - Content-Type : application/json - X-Auth-Token : auth_token Auth-token is the token created in the moment an API user is created in the database (documentation here ). Example of a DELETE request to delete variants: curl -X DELETE \\ -H 'Content-Type: application/json' \\ -H 'X-Auth-Token: auth_token' \\ -d '{\"dataset_id\": \"test_public\", \"samples\" : [\"ADM1059A1\", \"ADM1059A2\"]}' http://localhost:5000/apiv1.0/delete","title":"Removing variants for one or more samples by using the API"},{"location":"removing/#removing-a-specific-dataset","text":"Use the command to remove a dataset from the database: beacon delete dataset --id <dataset_id>","title":"Removing a specific dataset"},{"location":"systemd/","text":"Deploying the app as a service using systemd and Podman This short guide is intended as an example of configuration (please note that it is experimental and as such not to be used in production!) for system admins who would like to deploy the Beacon as a service using Linux systemd unit config files. Prerequisites Linux OS Podman version >= 2.0.4 To run Podman from Windows or MacOS you either use a remote client or run Linux inside a virtual machine . Creating a common directory for service files After having installed podman on your linux-like machine, ssh into this machine and create a folder in the user's home directory. This directory will contain all systemd unit config files: mkdir -p ~/.config/systemd/user MongoDB service file First thing to do is choosing a MongoDB image to use as database. You could use either the official MongoDB image or any other MongoDB image you prefer. For the sake of this documentation, let's use the lightweight MongoDB image(mvertes/alpine-mongo). Pull the image from Docker Hub: podman pull mvertes/alpine-mongo Assign the image a name, so it will be later used in the systemd service file. In this case the name will be beacon-mongo : podman run --security-opt=seccomp=unconfined -d --name beacon-mongo -p 27017:27017 alpine-mongo Create a service file for MongoDB with the following command: podman generate systemd --name beacon-mongo The content of this file will look like this: # container-beacon-mongo.service # autogenerated by Podman 3.2.3 # Mon Mar 21 08:51:43 UTC 2022 [Unit] Description=Podman container-beacon-mongo.service Documentation=man:podman-generate-systemd(1) Wants=network.target After=network-online.target RequiresMountsFor=/run/user/1000/containers [Service] Environment=PODMAN_SYSTEMD_UNIT=%n Restart=on-failure TimeoutStopSec=70 ExecStart=/usr/bin/podman start beacon-mongo ExecStop=/usr/bin/podman stop -t 10 beacon-mongo ExecStopPost=/usr/bin/podman stop -t 10 beacon-mongo PIDFile=/run/user/1000/containers/overlay-containers/2414fc2edfaf56869d7f31367ba23caf5f2a247d2ae88b62fc8d797362232878/userdata/conmon.pid Type=forking [Install] WantedBy=multi-user.target default.target Add the following line to this file, in the [Unit] section: BindsTo=beacon-mongo.service Create a service config file under ~/.config/systemd/user: touch ~/.config/systemd/user/beacon-mongo.service And copy the generated file content into this service file. After creating the unit file, to start the container automatically at boot time, type the following: systemctl --user daemon-reload systemctl --user enable beacon-mongo.service Once the service is enabled, it will start at boot time. To start it immediately and check the status of the service, type the following: systemctl --user start beacon-mongo.service systemctl --user status beacon-mongo.service To stop the service type the following command: systemctl --user stop beacon-mongo.service Beacon cli service file podman create --name beacon clinicalgenomics/cgbeacon2 Create the service file under ~/.config/systemd/user: touch ~/.config/systemd/user/beacon-cli.service Generate the systemd file content: podman generate systemd --name beacon Add the content of the service file to the service file: vi ~/.config/systemd/user/beacon-cli.service Don't forget to include this line under the [Unit] section: Requires= beacon-mongo.service Reload services and enable beacon-cli systemctl --user daemon-reload systemctl --user enable beacon-cli.service Beacon web service file Let's create a service config file to start the Beacon web app and keep it running. podman create --name beacon-web clinicalgenomics/cgbeacon2-server Create the service file under ~/.config/systemd/user: Let's add the following unit file to the ~/.config/systemd/user folder: touch ~/.config/systemd/user/beacon-web.service Let's add the following content to the file # beacon-web.service [Unit] Description=Podman beacon-web.service Documentation=man:podman-generate-systemd(1) Requires= beacon-mongo.service Wants=network.target After=network-online.target [Service] Environment=PODMAN_SYSTEMD_UNIT=%n Restart=no # Eventually turn this into on-failure ExecStart=/usr/bin/podman run \\ --env \"MONGODB_HOST=mongodb\" \\ --security-opt=seccomp=unconfined \\ --log-driver=journald \\ --name beacon-web \\ --tz local \\ -p 8000:8000 \\ clinicalgenomics/cgbeacon2-server ExecStop=/usr/bin/podman stop beacon-web ExecStopPost=/usr/bin/podman rm --ignore -f beacon-web TimeoutStartSec=1800s Type=forking [Install] WantedBy=multi-user.target default.target Reload services and enable beacon-cli systemctl --user daemon-reload systemctl --user enable beacon-web.service Once the service is enabled, it will start at boot time. To start it immediately and check the status of the service, type the following: systemctl --user start beacon-web.service systemctl --user status beacon-web.service Output from the command above: \u25cf beacon-web.service - Podman beacon-web.service Loaded: loaded (/home/vagrant/.config/systemd/user/beacon-web.service; enabled; vendor preset: enabled) Active: activating (start) since Mon 2022-03-21 10:48:00 UTC; 3min 23s ago Docs: man:podman-generate-systemd(1) Cntrl PID: 5390 (podman) CGroup: /user.slice/user-1000.slice/user@1000.service/beacon-web.service \u251c\u25005390 /usr/bin/podman run --env MONGODB_HOST=mongodb --security-opt=seccomp=unconfined --log-driver=journald --name beacon-web --tz local -p 8000:> \u251c\u25005402 /usr/bin/slirp4netns --disable-host-loopback --mtu=65520 --enable-sandbox --enable-seccomp -c -e 3 -r 4 --netns-type=path /run/user/1000/net> \u251c\u25005404 containers-rootlessport \u251c\u25005408 /usr/bin/fuse-overlayfs -o ,lowerdir=/home/vagrant/.local/share/containers/storage/overlay/l/UVIOW4TMABJJK5NP2TTAZQXCND:/home/vagrant/.local> \u251c\u25005412 containers-rootlessport-child \u251c\u25005419 /usr/bin/conmon --api-version 1 -c 5fc523663bdf26efee7af191ad4c70e184e05c3c1ec43bfd2c8541b23638c599 -u 5fc523663bdf26efee7af191ad4c70e184e05> \u2514\u25005fc523663bdf26efee7af191ad4c70e184e05c3c1ec43bfd2c8541b23638c599 \u251c\u25005427 /bin/sh -c gunicorn --workers=$GUNICORN_WORKERS --bind=$GUNICORN_BIND --threads=$GUNICORN_THREADS --timeout=$GUNICORN_TIM> \u251c\u25005438 /venv/bin/python /venv/bin/gunicorn --workers=1 --bind=0.0.0.0:8000 --threads=1 --timeout=400 --proxy-protocol --forwarded-allow-ips=10.0.> \u2514\u25005440 /venv/bin/python /venv/bin/gunicorn --workers=1 --bind=0.0.0.0:8000 --thread To stop the service type the following command: systemctl --user stop beacon-web.service","title":"Deploying the app as a service using systemd and podman"},{"location":"systemd/#deploying-the-app-as-a-service-using-systemd-and-podman","text":"This short guide is intended as an example of configuration (please note that it is experimental and as such not to be used in production!) for system admins who would like to deploy the Beacon as a service using Linux systemd unit config files.","title":"Deploying the app as a service using systemd and Podman"},{"location":"systemd/#prerequisites","text":"Linux OS Podman version >= 2.0.4 To run Podman from Windows or MacOS you either use a remote client or run Linux inside a virtual machine .","title":"Prerequisites"},{"location":"systemd/#creating-a-common-directory-for-service-files","text":"After having installed podman on your linux-like machine, ssh into this machine and create a folder in the user's home directory. This directory will contain all systemd unit config files: mkdir -p ~/.config/systemd/user","title":"Creating a common directory for service files"},{"location":"systemd/#mongodb-service-file","text":"First thing to do is choosing a MongoDB image to use as database. You could use either the official MongoDB image or any other MongoDB image you prefer. For the sake of this documentation, let's use the lightweight MongoDB image(mvertes/alpine-mongo). Pull the image from Docker Hub: podman pull mvertes/alpine-mongo Assign the image a name, so it will be later used in the systemd service file. In this case the name will be beacon-mongo : podman run --security-opt=seccomp=unconfined -d --name beacon-mongo -p 27017:27017 alpine-mongo Create a service file for MongoDB with the following command: podman generate systemd --name beacon-mongo The content of this file will look like this: # container-beacon-mongo.service # autogenerated by Podman 3.2.3 # Mon Mar 21 08:51:43 UTC 2022 [Unit] Description=Podman container-beacon-mongo.service Documentation=man:podman-generate-systemd(1) Wants=network.target After=network-online.target RequiresMountsFor=/run/user/1000/containers [Service] Environment=PODMAN_SYSTEMD_UNIT=%n Restart=on-failure TimeoutStopSec=70 ExecStart=/usr/bin/podman start beacon-mongo ExecStop=/usr/bin/podman stop -t 10 beacon-mongo ExecStopPost=/usr/bin/podman stop -t 10 beacon-mongo PIDFile=/run/user/1000/containers/overlay-containers/2414fc2edfaf56869d7f31367ba23caf5f2a247d2ae88b62fc8d797362232878/userdata/conmon.pid Type=forking [Install] WantedBy=multi-user.target default.target Add the following line to this file, in the [Unit] section: BindsTo=beacon-mongo.service Create a service config file under ~/.config/systemd/user: touch ~/.config/systemd/user/beacon-mongo.service And copy the generated file content into this service file. After creating the unit file, to start the container automatically at boot time, type the following: systemctl --user daemon-reload systemctl --user enable beacon-mongo.service Once the service is enabled, it will start at boot time. To start it immediately and check the status of the service, type the following: systemctl --user start beacon-mongo.service systemctl --user status beacon-mongo.service To stop the service type the following command: systemctl --user stop beacon-mongo.service","title":"MongoDB service file"},{"location":"systemd/#beacon-cli-service-file","text":"podman create --name beacon clinicalgenomics/cgbeacon2 Create the service file under ~/.config/systemd/user: touch ~/.config/systemd/user/beacon-cli.service Generate the systemd file content: podman generate systemd --name beacon Add the content of the service file to the service file: vi ~/.config/systemd/user/beacon-cli.service Don't forget to include this line under the [Unit] section: Requires= beacon-mongo.service Reload services and enable beacon-cli systemctl --user daemon-reload systemctl --user enable beacon-cli.service","title":"Beacon cli service file"},{"location":"systemd/#beacon-web-service-file","text":"Let's create a service config file to start the Beacon web app and keep it running. podman create --name beacon-web clinicalgenomics/cgbeacon2-server Create the service file under ~/.config/systemd/user: Let's add the following unit file to the ~/.config/systemd/user folder: touch ~/.config/systemd/user/beacon-web.service Let's add the following content to the file # beacon-web.service [Unit] Description=Podman beacon-web.service Documentation=man:podman-generate-systemd(1) Requires= beacon-mongo.service Wants=network.target After=network-online.target [Service] Environment=PODMAN_SYSTEMD_UNIT=%n Restart=no # Eventually turn this into on-failure ExecStart=/usr/bin/podman run \\ --env \"MONGODB_HOST=mongodb\" \\ --security-opt=seccomp=unconfined \\ --log-driver=journald \\ --name beacon-web \\ --tz local \\ -p 8000:8000 \\ clinicalgenomics/cgbeacon2-server ExecStop=/usr/bin/podman stop beacon-web ExecStopPost=/usr/bin/podman rm --ignore -f beacon-web TimeoutStartSec=1800s Type=forking [Install] WantedBy=multi-user.target default.target Reload services and enable beacon-cli systemctl --user daemon-reload systemctl --user enable beacon-web.service Once the service is enabled, it will start at boot time. To start it immediately and check the status of the service, type the following: systemctl --user start beacon-web.service systemctl --user status beacon-web.service Output from the command above: \u25cf beacon-web.service - Podman beacon-web.service Loaded: loaded (/home/vagrant/.config/systemd/user/beacon-web.service; enabled; vendor preset: enabled) Active: activating (start) since Mon 2022-03-21 10:48:00 UTC; 3min 23s ago Docs: man:podman-generate-systemd(1) Cntrl PID: 5390 (podman) CGroup: /user.slice/user-1000.slice/user@1000.service/beacon-web.service \u251c\u25005390 /usr/bin/podman run --env MONGODB_HOST=mongodb --security-opt=seccomp=unconfined --log-driver=journald --name beacon-web --tz local -p 8000:> \u251c\u25005402 /usr/bin/slirp4netns --disable-host-loopback --mtu=65520 --enable-sandbox --enable-seccomp -c -e 3 -r 4 --netns-type=path /run/user/1000/net> \u251c\u25005404 containers-rootlessport \u251c\u25005408 /usr/bin/fuse-overlayfs -o ,lowerdir=/home/vagrant/.local/share/containers/storage/overlay/l/UVIOW4TMABJJK5NP2TTAZQXCND:/home/vagrant/.local> \u251c\u25005412 containers-rootlessport-child \u251c\u25005419 /usr/bin/conmon --api-version 1 -c 5fc523663bdf26efee7af191ad4c70e184e05c3c1ec43bfd2c8541b23638c599 -u 5fc523663bdf26efee7af191ad4c70e184e05> \u2514\u25005fc523663bdf26efee7af191ad4c70e184e05c3c1ec43bfd2c8541b23638c599 \u251c\u25005427 /bin/sh -c gunicorn --workers=$GUNICORN_WORKERS --bind=$GUNICORN_BIND --threads=$GUNICORN_THREADS --timeout=$GUNICORN_TIM> \u251c\u25005438 /venv/bin/python /venv/bin/gunicorn --workers=1 --bind=0.0.0.0:8000 --threads=1 --timeout=400 --proxy-protocol --forwarded-allow-ips=10.0.> \u2514\u25005440 /venv/bin/python /venv/bin/gunicorn --workers=1 --bind=0.0.0.0:8000 --thread To stop the service type the following command: systemctl --user stop beacon-web.service","title":"Beacon web service file"}]}